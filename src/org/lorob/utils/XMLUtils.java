package org.lorob.utils;

import java.io.File;
import java.io.UnsupportedEncodingException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;

import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.xml.sax.SAXParseException;

/**
 * Class to generate XSL,XML and HTML files from
 * database results and schema
 * @author lorob
 *
 */
public class XMLUtils
{
	/**
	 * Method for generating XML by executing SQL query
     * 
	 * @param sqlCommand
	 * @param connection
	 * @return
	 * @throws Exception
	 */
	public static StringBuffer generateXML(String sqlCommand,Connection connection) 
    	throws Exception
    {
    	StringBuffer buf = new StringBuffer("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");  
        buf.append("<!--\n");
        buf.append("This document is automatically generated by BizViewer\n");
        buf.append("-->\n");
            
        try
        {
        	
            Statement stmt = connection.createStatement();
            ResultSet rs = stmt.executeQuery(sqlCommand);
            buf.append("<XMLView>\n");
            
            // loop through resultset
            ResultSetMetaData rsmd = rs.getMetaData();
            int numCols = rsmd.getColumnCount();
            buf.append("    <metadata>\r\n");
            for(int j=1; j<=numCols; j++)
            {
            	buf.append("        <");
                StringBuffer tableName=getTableName(rsmd,j);
                buf.append(tableName.toString());
                buf.append(rsmd.getColumnLabel(j)+" datatype=\""
                        +rsmd.getColumnTypeName(j)+"\"/>\r\n");
            }
            buf.append("    </metadata>\r\n");
            while (rs.next()) 
            {
                buf.append("    <queryResult");
                buf.append(">\n");
                for (int i = 1; i <= numCols; i++) 
                {   
                    // Loop to get table and column name
                    buf.append("        <");
                    StringBuffer tableName=getTableName(rsmd,i);
                    buf.append(tableName.toString());
                    buf.append(rsmd.getColumnLabel(i));
                    buf.append(">");
                    buf.append(Strings.makeXMLCompatible(rs.getString(i)));
                    buf.append("</");
                    buf.append(tableName.toString());
                    buf.append(rsmd.getColumnLabel(i));
                    buf.append(">\n");
                }
                buf.append("    </");
                buf.append("queryResult");
                buf.append(">\n");
            }
            buf.append("</XMLView>\n");
            stmt.close();
        }
        catch(SQLException sqle)
        {
        	StringBuffer sqlMessage=new StringBuffer("SQL Executed:");
        	sqlMessage.append(sqlCommand);
        	sqlMessage.append("\n");
        	sqlMessage.append(sqle.getMessage());
        	SQLException sqle2=new SQLException(sqlMessage.toString(),sqle.getSQLState(),sqle.getErrorCode());
        	throw sqle2;
        }
        catch (Exception e) 
        {
        	//setErrorScreen(e);
            //return null;
        	throw e;
        }
        return buf;
    }
    
	/**
	 * 
	 * Method for generating HTML from specified XML file and XSL file
     * @param xmlFile
	 * @param xslFile
	 * @param htmlFile
	 * @throws Exception
	 */
    public static  void generateHTML(File xmlFile,File xslFile,File htmlFile) throws Exception
    {
    
        Source xmlSource = new StreamSource(xmlFile.toString());
        Source xslSource = new StreamSource(xslFile.toString());
        //System.out.println("xml="+xmlFile.toString());
        //System.out.println("xsl="+xslFile.toString());
        //System.out.println("html="+htmlFile.toString());
    
        //Transform XML to HTML using appropriate XSL
        TransformerFactory transFact = TransformerFactory.newInstance();
        Transformer trans = transFact.newTransformer(xslSource);
        try
        {
            trans.transform(xmlSource, new StreamResult(htmlFile.toString()));
        }
        catch(TransformerException tfe)
        {
            System.out.println(">>>>"+tfe.getMessageAndLocation());
            if(tfe.getLocator()!=null)
            {
            	System.out.println(">>>>"+tfe.getLocator().getLineNumber());
            	System.out.println(">>>>"+tfe.getLocator().getColumnNumber());
            }
            throw tfe;
        }
        catch(Exception e)
        {
        	// this is here for older versions of the
        	// parser which used to throw SAXParseException 
            if(e instanceof SAXParseException)
            {
                SAXParseException spe=(SAXParseException)e;
                System.out.println(">>>"+spe.getLineNumber());
                System.out.println(">>>"+spe.getColumnNumber());
                throw spe;
            }
            throw e;
        }
        
    }     
    
    /**
     * Generate XSL from handed sql statement to display
     * results in
     * @param sqlCommand
     * @param connection
     * @return
     * @throws Exception
     */
    public static  StringBuffer generateXSL(String sqlCommand,Connection connection) throws Exception
    {
        int i;
        StringBuffer buf = new StringBuffer("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
        buf.append("<!--\n");
        buf.append("This document is automatically generated by BizViewer XmlView\n");
        buf.append("-->\n");
        buf.append("<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n");
        buf.append("<xsl:template match=\"/\"> \n");
        buf.append("<html>\n");
        buf.append("  <head> \n");
        buf.append("  <title>HTML view for XML file with XSL</title> \n");
        buf.append("  </head>\n");
        buf.append("    <body>\n");
       // buf.append("    <p>XMLView with XSL</p>\n");
        buf.append("    <xsl:for-each select="+"\"XMLView\""+">\n");
        buf.append("    <table border=\"1\">\n");
        buf.append("      <tr>\n");
        
        //Loop through resultset to get column label
        try 
        { 
            //DatabaseMetaData dMeta = mConnection.getMetaData();
            //ResultSet result=dMeta.getTables(null,null,null,null);
            Statement state = connection.createStatement();
            ResultSet rs = state.executeQuery(sqlCommand);
            ResultSetMetaData rsmd = rs.getMetaData();
            int numCols = rsmd.getColumnCount();
                    
            for (i = 1; i <= numCols; i++) 
            {
                String columnLabel = rsmd.getColumnLabel(i);
                buf.append("        <td> <font color=\"red\" size=\"3\"> ");
                buf.append(getTableName(rsmd,i).toString());
                buf.append(columnLabel +"</font></td>\n");                
            }
              
            buf.append("        </tr>\n");
            buf.append("        <xsl:for-each select=\"queryResult\">\n");
            buf.append("        <tr>\n");
              
            for (i = 1; i <= numCols; i++) 
            {
                String columnLabel = rsmd.getColumnLabel(i);
                buf.append("        <td><font size=\"3\"> <xsl:value-of select= \"");
                buf.append(getTableName(rsmd,i).toString());
                buf.append(columnLabel+" \"/></font></td>\n"); 
            }           

        }
        catch(SQLException sqle)
        {
        	StringBuffer sqlMessage=new StringBuffer("SQL Executed:");
        	sqlMessage.append(sqlCommand);
        	sqlMessage.append("\n");
        	sqlMessage.append(sqle.getMessage());
        	SQLException sqle2=new SQLException(sqlMessage.toString(),sqle.getSQLState(),sqle.getErrorCode());
        	throw sqle2;
        }
        catch (Exception e)
        {
            throw e;
        }

        buf.append("        </tr>\n");
        buf.append("      </xsl:for-each>\n");
        buf.append("      </table>\n");
        buf.append("      </xsl:for-each>\n");
        buf.append("    </body>\n");
        buf.append("  </html>\n");
        buf.append(" </xsl:template>\n");
        buf.append("</xsl:stylesheet>\n");
        buf.append("\n");
        return buf;
    }
    
    /**
     * Poor mans negative conversion. No check on 
     * code page !
     * @param toConvert
     * @return
     */
    public static String poorMansEBCIDIC2ASCIISignedConversion(String toConvert)
    {
    	if(toConvert==null||toConvert.length()==0)
    	{
    		// nothing to do
    		return toConvert;
    	}
    	int length=toConvert.length();
    	char lastChar=toConvert.charAt(length-1);
    	if(Character.isDigit(lastChar)==true)
    	{
    		// not a minus
    		return toConvert;
    	}
    	int minusValue=0;
    	switch(lastChar)
    	{
    		case 'p':
    		case 'P':
    			break;
    		case 'q':
    		case 'Q':
    			minusValue=-1;
    			break;
    		case 'r':
    		case 'R':
    			minusValue=-2;
    			break;
    		case 's':
    		case 'S':
    			minusValue=-3;
    			break;
    		case 't':
    		case 'T':
    			minusValue=-4;
    			break;
    		case 'u':
    		case 'U':
    			minusValue=-5;
    			break;
    		case 'v':
    		case 'V':
    			minusValue=-6;
    			break;
    		case 'w':
    		case 'W':
    			minusValue=-7;
    			break;
    		case 'x':
    		case 'X':
    			minusValue=-8;
    			break;
    		case 'y':
    		case 'Y':
    			minusValue=-9;
    			break;
    	}
    	// minus
    	int intValue=Integer.parseInt(toConvert.substring(0,length-1));
    	
    	intValue=intValue*-10;
    	intValue=intValue+minusValue;
    	
    	return Integer.toString(intValue);
    }
    
    /** Converts passed in EBCIDIC string
     * to ASCII equivalent
     * @param toConvert
     * @return String of converted string
     * @throws  UnsupportedEncodingException
     */
    public static String EBCIDIC2ASCIISignedConversion(String toConvert)
    	throws UnsupportedEncodingException
    {
    	// we wish to convert a numeric EBCIDIC hex signed string
    	// to ascii
    	// System 390 EBCDIC
    	String encoding = "CP500";  // EBCDIC 500V1
    	//String encoding = "Cp1047";  // Latin-1 character set for EBCDIC hosts 
    	byte[] ebcdic = toConvert.getBytes( encoding );
    	byte[] converted=new byte[ebcdic.length];
    	
    	boolean isNegative=false;
    	for(int i=0;i<ebcdic.length;i++)
    	{
    		int convertedChar=((int)ebcdic[i])&0xff;
    		if(i==ebcdic.length-1)
    		{
    			// are we signed
    			if(convertedChar<240||convertedChar>249)
    			{
    				if(convertedChar>=162&&convertedChar<=168) // s,t,u,v,w,x,y
    				{
    					convertedChar=convertedChar-175;
    				}
    				else if(convertedChar>=151&&convertedChar<=153) // p ,q, r
    				{
    					convertedChar=convertedChar-167;
    				}
    				isNegative=true;
    			}
    		}
    		converted[i]=(byte)convertedChar;
    	}
    	String  reconsituted = new String( ebcdic ,encoding );
    	if(isNegative)
    	{
    		byte[] negativeConverted=new byte[ebcdic.length+1];
    		negativeConverted[0]=(byte)new String("-").getBytes(encoding)[0];
    		for(int i=0;i<ebcdic.length;i++)
        	{
    			negativeConverted[i+1]=converted[i];
        	}
    		reconsituted = new String( negativeConverted, encoding );
        	return reconsituted;
    	}
    	// return
    	reconsituted = new String( ebcdic,encoding );
    	return reconsituted;
    }
    
    /**
     * Get the table name from the meta data
     * adds schema for example DB_SCHEMA.TABLE_NAME
     * @param rsmd
     * @param j
     * @return
     * @throws Exception
     */
    public static  StringBuffer getTableName(ResultSetMetaData rsmd,int j)
    	throws Exception
    {
		StringBuffer buf=new StringBuffer();
	    String tableName=rsmd.getTableName(j);
	    if(tableName==null||tableName.length()==0)
	    {
	        tableName=rsmd.getSchemaName(j);
	        if(tableName==null||tableName.length()==0)
	        {
	            tableName=rsmd.getCatalogName(j);
	        }
	    }
	    // hack for excel which has $ at the end of tables.
	    // this cocks up the xml parser if used.
	    // Typical Microsoft quality
	    if(tableName.endsWith("$")==true)
	    {
	    	tableName=tableName.substring(0,tableName.length()-1);
	    }
	    if(tableName.length()>0)
	    {
	        buf.append(tableName+".");
	    }
	    return buf;
	}
    
   
}
